<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>未来派交互界面 (FUI) 原型 V17.4 (赤道视角居中)</title>
    
    <!-- 
    =================================================================
    🎯 FUI TEMPLATE USAGE GUIDE - FUI模板使用指南
    =================================================================
    
    📖 模板说明：
    这是一个用于3D球状界面的LLM内容生成模板。主要用于快速替换内容而无需重新生成整个界面代码。
    
    🔄 主要替换区域：
    1. DYNAMIC CONTENT ZONE (动态内容区域)
       - 位置：JavaScript 中的 contentTemplates 数组
       - 内容：卡片标题和内容
       - 格式：{ title: 'xxx', content: () => `html内容` }
    
    ⚙️ 可选配置：
    1. 卡片数量：自动根据contentTemplates数组长度确定
    2. 内容更新间隔：init函数中的setInterval时间
    
    🎨 内容样式指南：
    - 支持HTML标签：<p>, <span>, <br> 等
    - 可用CSS类：.text-green-400, .code-string, .font-bold 等
    - 支持动态JS变量：${Date.now()}, ${Math.random()} 等
    - 推荐使用表情符号和特殊字符增强视觉效果
    
    ❌ 不建议修改的区域：
    - CSS样式定义
    - JavaScript函数逻辑
    - HTML结构框架
    - 物理和动画参数
    
    =================================================================
    -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@300;400;500&family=Teko:wght@300;400;500&display=swap" rel="stylesheet">
    <style>
        * {
            box-sizing: border-box;
        }
        
        html {
            margin: 0;
            padding: 0;
            background: rgb(0, 0, 0) !important;
        }
        
        :root {
            --fui-primary: #a7d5ff;
            --fui-secondary: #ffa500;
            --fui-bg: #03080f;
            --fui-panel-bg: rgba(15, 35, 60, 0.5);
            --fui-border-color: rgba(135, 206, 250, 0.3);
            
            /* Highlight Colors */
            --highlight-color-pink: #EC4899;
            --highlight-color-blue: #3B82F6;
            --highlight-color-yellow: #FBBF24;
            --highlight-bg-pink: rgba(236, 72, 153, 0.15);
            --highlight-border-pink: rgba(236, 72, 153, 0.6);
            --highlight-bg-blue: rgba(59, 130, 246, 0.15);
            --highlight-border-blue: rgba(59, 130, 246, 0.6);
            --highlight-bg-yellow: rgba(251, 191, 36, 0.15);
            --highlight-border-yellow: rgba(251, 191, 36, 0.6);
        }

        body {
            background-color: rgb(8, 20, 35) !important;
            background-image: radial-gradient(circle at center, rgb(15, 35, 60) 0%, rgb(12, 28, 50) 60%, rgb(8, 20, 35) 85%, rgb(3, 8, 15) 100%) !important;
            color: var(--fui-primary);
            font-family: 'Roboto Mono', monospace;
            overflow: hidden;
            cursor: grab;
            min-height: 100vh;
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
        }
        .perspective-container {
            width: 100%;
            height: 100%;
            perspective: 2500px;
            position: absolute;
            transform-style: preserve-3d;
        }
        .scene-origin {
            width: 100%;
            height: 100%;
            position: absolute;
            transform-style: preserve-3d;
            will-change: transform;
        }
        .fui-window {
            position: absolute;
            top: 50%; left: 50%;
            background: var(--fui-panel-bg);
            backdrop-filter: blur(10px);
            border: 1px solid var(--fui-border-color);
            border-radius: 12px;
            box-shadow: 0 0 25px rgba(0, 150, 255, 0.1);
            transform-style: preserve-3d;
            transition: box-shadow 0.3s ease, border-color 0.3s ease, background 0.4s ease, opacity 0.5s ease;
            will-change: transform, background, border-color, opacity;
            user-select: none;
        }
        .fui-window.focused {
            border-color: rgba(255, 165, 0, 0.7);
            box-shadow: 0 0 35px rgba(255, 165, 0, 0.6);
            z-index: 2000 !important;
        }
        .fui-header {
            background: rgba(135, 206, 250, 0.1);
            padding: 12px 20px;
            cursor: grab;
            border-bottom: 1px solid rgba(135, 206, 250, 0.2);
            font-family: 'Teko', sans-serif;
            font-size: 1.5rem; /* 24px */
            letter-spacing: 0.05em;
        }
        .fui-content {
            padding: 20px;
            font-size: 14px;
            line-height: 1.7;
            overflow-y: auto;
            overflow-x: hidden;
            word-wrap: break-word;
            scrollbar-width: thin;
            scrollbar-color: rgba(255, 165, 0, 0.5) transparent;
        }
        .fui-content::-webkit-scrollbar {
            width: 6px;
        }
        .fui-content::-webkit-scrollbar-track {
            background: transparent;
        }
        .fui-content::-webkit-scrollbar-thumb {
            background: rgba(255, 165, 0, 0.5);
            border-radius: 3px;
        }
        .fui-content::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 165, 0, 0.8);
        }
        .resize-handle {
            position: absolute;
            right: 0; bottom: 0; width: 20px; height: 20px;
            cursor: se-resize; z-index: 10;
            border-bottom: 2px solid rgba(255, 165, 0, 0.5);
            border-right: 2px solid rgba(255, 165, 0, 0.5);
        }
        .controls-panel {
            position: fixed;
            top: 15px; right: 15px; background: rgba(15, 35, 60, 0.7);
            backdrop-filter: blur(10px); border: 1px solid var(--fui-border-color);
            border-radius: 8px; padding: 8px 12px; z-index: 3000;
            font-family: 'Teko', sans-serif; letter-spacing: 0.05em;
        }
        .control-label { font-size: 0.9rem; color: var(--fui-primary); }
        .control-value { font-size: 0.9rem; color: var(--fui-secondary); }
        .control-slider {
            -webkit-appearance: none; appearance: none;
            width: 100px; height: 3px; background: rgba(135, 206, 250, 0.3); outline: none;
            border-radius: 2px; transition: background 0.3s; margin-top: 2px;
        }
        .control-slider::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none;
            width: 14px; height: 14px; background: var(--fui-secondary);
            cursor: pointer; border-radius: 50%; border: 2px solid var(--fui-bg);
        }
        .control-slider::-moz-range-thumb {
            width: 14px; height: 14px; background: var(--fui-secondary);
            cursor: pointer; border-radius: 50%; border: 2px solid var(--fui-bg);
        }
        .code-keyword { color: #c792ea; }
        .code-string { color: #c3e88d; }
        .code-comment { color: #546e7a; }
        .code-variable { color: #82aaff; }

        /* --- Radial Menu --- */
        .radial-menu-container {
            position: absolute; width: 240px; height: 240px;
            pointer-events: none; opacity: 0; z-index: 50;
            clip-path: polygon(50% 50%, 50% 0%, 50% 0%);
            transition: opacity 0.4s ease-out, clip-path 0.4s cubic-bezier(0.45, 0, 0.55, 1);
        }
        .radial-menu-container.active {
            opacity: 1; pointer-events: auto;
            clip-path: polygon(50% 50%, 50% 0%, 100% 0%, 100% 100%, 0% 100%, 0% 0%, 50% 0%);
        }
        .radial-menu-arc {
            position: absolute; width: 100%; height: 100%;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(15, 35, 60, 0.1) 40%, rgba(135, 206, 250, 0.3) 68%, rgba(135, 206, 250, 0.5) 70%, transparent 71%);
            box-shadow: 0 0 20px rgba(135, 206, 250, 0.3) inset;
        }
        .radial-menu-item {
            position: absolute; top: 50%; left: 50%;
            margin: -18px; width: 36px; height: 36px;
            background: rgba(15, 35, 60, 0.7);
            border: 1px solid rgba(135, 206, 250, 0.5);
            border-radius: 50%; display: flex; align-items: center; justify-content: center;
            cursor: pointer; color: var(--fui-primary); opacity: 0;
            transform: translate(var(--tx, 0px), var(--ty, 0px)) scale(0);
            transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.3s ease-out, background 0.2s, border-color 0.2s;
            transition-delay: var(--delay, 0s);
        }
        .radial-menu-container.active .radial-menu-item {
            transform: translate(var(--tx, 0px), var(--ty, 0px)) scale(1);
            opacity: 1;
        }
        .radial-menu-item:hover {
            background: rgba(255, 165, 0, 0.4);
            border-color: rgba(255, 165, 0, 0.8);
            transform: translate(var(--tx, 0px), var(--ty, 0px)) scale(1.15);
        }

        /* --- Marker Dots --- */
        .marker-dots {
            position: absolute; top: 15px; right: 15px;
            display: flex; gap: 8px; z-index: 20;
        }
        .marker-dot {
            width: 8px; height: 8px;
            border-radius: 50%; cursor: pointer;
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .marker-dot:hover {
            transform: scale(1.4);
            box-shadow: 0 0 6px currentColor;
        }
        .dot-pink { background-color: var(--highlight-color-pink); color: var(--highlight-color-pink);}
        .dot-blue { background-color: var(--highlight-color-blue); color: var(--highlight-color-blue);}
        .dot-yellow { background-color: var(--highlight-color-yellow); color: var(--highlight-color-yellow);}
        .fui-window.highlight-pink {
            background: var(--highlight-bg-pink) !important;
            border-color: var(--highlight-border-pink);
        }
        .fui-window.highlight-blue {
            background: var(--highlight-bg-blue) !important;
            border-color: var(--highlight-border-blue);
        }
        .fui-window.highlight-yellow {
            background: var(--highlight-bg-yellow) !important;
            border-color: var(--highlight-border-yellow);
        }

        /* --- Center Card Highlight --- */
        .fui-window.center-highlight {
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.3), 0 0 50px rgba(255, 215, 0, 0.15) !important;
            border-color: rgba(255, 215, 0, 0.5) !important;
            transform-style: preserve-3d;
            animation: centerCardPulse 3s ease-in-out infinite;
        }

        @keyframes centerCardPulse {
            0%, 100% { 
                box-shadow: 0 0 25px rgba(255, 215, 0, 0.3), 0 0 50px rgba(255, 215, 0, 0.15);
            }
            50% { 
                box-shadow: 0 0 30px rgba(255, 215, 0, 0.4), 0 0 60px rgba(255, 215, 0, 0.2);
            }
        }

        /* --- 中心定位标记 --- */
        .center-crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            width: 60px;
            height: 60px;
            transform: translate(-50%, -50%);
            z-index: 100;
            pointer-events: none;
        }

        .crosshair-ring {
            position: absolute;
            width: 100%;
            height: 100%;
            border: 2px solid transparent;
            border-radius: 50%;
            animation: crosshairPulse 2s ease-in-out infinite;
        }

        .crosshair-ring:nth-child(1) {
            border-color: rgba(135, 206, 250, 0.8);
            animation-delay: 0s;
        }

        .crosshair-ring:nth-child(2) {
            border-color: rgba(255, 165, 0, 0.6);
            animation-delay: 0.5s;
            width: 80%;
            height: 80%;
            top: 10%;
            left: 10%;
        }

        .crosshair-ring:nth-child(3) {
            border-color: rgba(135, 206, 250, 0.4);
            animation-delay: 1s;
            width: 60%;
            height: 60%;
            top: 20%;
            left: 20%;
        }

        .crosshair-center {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 8px;
            height: 8px;
            background: radial-gradient(circle, rgba(255, 165, 0, 0.9) 0%, rgba(135, 206, 250, 0.6) 100%);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 20px rgba(255, 165, 0, 0.8);
            animation: centerDot 1.5s ease-in-out infinite alternate;
        }

        @keyframes crosshairPulse {
            0%, 100% {
                transform: scale(1);
                opacity: 0.4;
            }
            50% {
                transform: scale(1.2);
                opacity: 0.8;
            }
        }

        @keyframes centerDot {
            0% {
                box-shadow: 0 0 20px rgba(255, 165, 0, 0.8);
            }
            100% {
                box-shadow: 0 0 30px rgba(255, 165, 0, 1), 0 0 50px rgba(135, 206, 250, 0.5);
            }
        }

        /* --- Holographic Light Globe --- */
        .visual-navigation {
            position: fixed;
            top: 15px;
            left: 15px;
            width: 140px;
            height: 140px;
            z-index: 3000;
            perspective: 600px;
        }
        
        .nav-globe-container {
            width: 100%;
            height: 100%;
            transform-style: preserve-3d;
            position: relative;
            animation: holoGlobeFloat 6s ease-in-out infinite;
        }
        
        .nav-globe {
            width: 100px;
            height: 100px;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transform-style: preserve-3d;
            border-radius: 50%;
            background: transparent;
            overflow: visible;
        }
        
        /* 全息光球外层 */
        .holo-sphere-outer {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, 
                rgba(167, 213, 255, 0.05) 0%, 
                rgba(135, 206, 250, 0.12) 30%, 
                rgba(15, 35, 60, 0.20) 60%,
                rgba(255, 165, 0, 0.08) 80%,
                transparent 100%);
            border: 2px solid rgba(135, 206, 250, 0.3);
            box-shadow: 
                0 0 35px rgba(135, 206, 250, 0.3),
                inset 0 0 25px rgba(167, 213, 255, 0.15),
                inset 0 0 50px rgba(255, 165, 0, 0.05);
            animation: holoSphereOuter 8s ease-in-out infinite;
        }
        
        /* 全息光球内层 */
        .holo-sphere-inner {
            position: absolute;
            width: 75%;
            height: 75%;
            top: 12.5%;
            left: 12.5%;
            border-radius: 50%;
            background: radial-gradient(circle, 
                rgba(167, 213, 255, 0.15) 0%, 
                rgba(135, 206, 250, 0.08) 40%, 
                rgba(255, 165, 0, 0.05) 70%,
                transparent 85%);
            border: 1px solid rgba(135, 206, 250, 0.4);
            box-shadow: 
                0 0 20px rgba(135, 206, 250, 0.2),
                inset 0 0 15px rgba(167, 213, 255, 0.1);
            animation: holoSphereInner 5s ease-in-out infinite reverse;
        }
        
        /* 光波纹理层 */
        .light-wave {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: conic-gradient(
                transparent 0deg,
                rgba(135, 206, 250, 0.1) 45deg,
                transparent 90deg,
                rgba(167, 213, 255, 0.15) 135deg,
                transparent 180deg,
                rgba(135, 206, 250, 0.08) 225deg,
                transparent 270deg,
                rgba(167, 213, 255, 0.12) 315deg,
                transparent 360deg
            );
            animation: lightWaveRotate 12s linear infinite;
        }
        
        .light-wave::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: conic-gradient(
                rgba(255, 165, 0, 0.05) 0deg,
                transparent 60deg,
                rgba(255, 165, 0, 0.1) 120deg,
                transparent 180deg,
                rgba(255, 165, 0, 0.08) 240deg,
                transparent 300deg,
                rgba(255, 165, 0, 0.06) 360deg
            );
            animation: lightWaveRotate 8s linear infinite reverse;
        }
        
        /* 脉冲光环 */
        .pulse-ring {
            position: absolute;
            border-radius: 50%;
            border: 1px solid rgba(135, 206, 250, 0.4);
            animation: pulsateRing 4s ease-in-out infinite;
        }
        
        .pulse-ring:nth-child(1) {
            width: 120%;
            height: 120%;
            top: -10%;
            left: -10%;
            animation-delay: 0s;
        }
        
        .pulse-ring:nth-child(2) {
            width: 90%;
            height: 90%;
            top: 5%;
            left: 5%;
            animation-delay: 1.5s;
            border-color: rgba(255, 165, 0, 0.3);
        }
        
        .pulse-ring:nth-child(3) {
            width: 60%;
            height: 60%;
            top: 20%;
            left: 20%;
            animation-delay: 3s;
            border-color: rgba(167, 213, 255, 0.5);
        }
        
        /* 光点（卡片指示器） */
        .nav-card-dot {
            position: absolute;
            width: 4px;
            height: 4px;
            background: rgba(255, 165, 0, 0.8);
            border-radius: 50%;
            transform-style: preserve-3d;
            transition: all 0.3s ease;
            box-shadow: 
                0 0 8px rgba(255, 165, 0, 0.6),
                0 0 16px rgba(255, 165, 0, 0.3);
            animation: dotFloat 3s ease-in-out infinite;
        }
        
        .nav-card-dot.center-dot {
            width: 6px;
            height: 6px;
            background: rgba(255, 215, 0, 1);
            box-shadow: 
                0 0 12px rgba(255, 215, 0, 0.8),
                0 0 24px rgba(255, 215, 0, 0.4),
                0 0 36px rgba(255, 215, 0, 0.2);
            animation: centerDotPulse 2s ease-in-out infinite, dotFloat 3s ease-in-out infinite;
        }
        
        .nav-card-dot:hover {
            transform: scale(2);
            z-index: 10;
            box-shadow: 
                0 0 16px rgba(255, 165, 0, 1),
                0 0 32px rgba(255, 165, 0, 0.6);
        }
        
        /* 深度增强层 */
        .holo-depth-enhancer {
            position: absolute;
            width: 90%;
            height: 90%;
            top: 5%;
            left: 5%;
            border-radius: 50%;
            background: 
                radial-gradient(ellipse 80% 60% at 25% 25%, 
                    rgba(167, 213, 255, 0.12) 0%, 
                    transparent 50%),
                radial-gradient(ellipse 60% 80% at 75% 75%, 
                    rgba(255, 165, 0, 0.08) 0%, 
                    transparent 50%);
            border: 1px solid rgba(135, 206, 250, 0.25);
            opacity: 0.8;
            animation: depthEnhancer 7s ease-in-out infinite;
        }
        
        /* 全息网格线 */
        .holo-grid {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: 
                linear-gradient(90deg, transparent 48%, rgba(135, 206, 250, 0.1) 49%, rgba(135, 206, 250, 0.1) 51%, transparent 52%),
                linear-gradient(0deg, transparent 48%, rgba(135, 206, 250, 0.1) 49%, rgba(135, 206, 250, 0.1) 51%, transparent 52%),
                radial-gradient(circle, transparent 20%, rgba(135, 206, 250, 0.05) 21%, rgba(135, 206, 250, 0.05) 22%, transparent 23%),
                radial-gradient(circle, transparent 40%, rgba(135, 206, 250, 0.05) 41%, rgba(135, 206, 250, 0.05) 42%, transparent 43%),
                radial-gradient(circle, transparent 60%, rgba(135, 206, 250, 0.05) 61%, rgba(135, 206, 250, 0.05) 62%, transparent 63%);
            animation: holoGridPulse 6s ease-in-out infinite;
        }
        
        .nav-globe-label {
            position: absolute;
            bottom: -30px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Teko', sans-serif;
            font-size: 0.75rem;
            color: var(--fui-primary);
            text-align: center;
            opacity: 0.6;
            letter-spacing: 0.1em;
            text-shadow: 0 0 10px rgba(135, 206, 250, 0.5);
            animation: labelGlow 4s ease-in-out infinite;
        }
        
        /* 动画定义 */
        @keyframes holoGlobeFloat {
            0%, 100% { transform: translateY(0px) rotateZ(0deg); }
            25% { transform: translateY(-2px) rotateZ(0.5deg); }
            50% { transform: translateY(0px) rotateZ(1deg); }
            75% { transform: translateY(2px) rotateZ(0.5deg); }
        }
        
        @keyframes holoSphereOuter {
            0%, 100% { 
                opacity: 0.3;
                transform: scale(1);
                box-shadow: 0 0 30px rgba(135, 206, 250, 0.2);
            }
            50% { 
                opacity: 0.6;
                transform: scale(1.05);
                box-shadow: 0 0 40px rgba(135, 206, 250, 0.4);
            }
        }
        
        @keyframes holoSphereInner {
            0%, 100% { 
                opacity: 0.4;
                transform: scale(1);
            }
            50% { 
                opacity: 0.7;
                transform: scale(1.1);
            }
        }
        
        @keyframes lightWaveRotate {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        @keyframes pulsateRing {
            0%, 100% { 
                opacity: 0.2;
                transform: scale(1);
            }
            50% { 
                opacity: 0.6;
                transform: scale(1.1);
            }
        }
        
        @keyframes centerDotPulse {
            0%, 100% { 
                box-shadow: 
                    0 0 12px rgba(255, 215, 0, 0.8),
                    0 0 24px rgba(255, 215, 0, 0.4);
                transform: scale(1);
            }
            50% { 
                box-shadow: 
                    0 0 20px rgba(255, 215, 0, 1),
                    0 0 40px rgba(255, 215, 0, 0.6),
                    0 0 60px rgba(255, 215, 0, 0.3);
                transform: scale(1.3);
            }
        }
        
        @keyframes dotFloat {
            0%, 100% { transform: translateZ(0px); }
            50% { transform: translateZ(5px); }
        }
        
        @keyframes holoGridPulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.7; }
        }
        
        @keyframes depthEnhancer {
            0%, 100% { 
                opacity: 0.6;
                transform: scale(1) rotateZ(0deg);
            }
            25% { 
                opacity: 0.8;
                transform: scale(1.02) rotateZ(90deg);
            }
            50% { 
                opacity: 0.9;
                transform: scale(1.05) rotateZ(180deg);
            }
            75% { 
                opacity: 0.8;
                transform: scale(1.02) rotateZ(270deg);
            }
        }
        
        @keyframes labelGlow {
            0%, 100% { 
                opacity: 0.6;
                text-shadow: 0 0 10px rgba(135, 206, 250, 0.5);
            }
            50% { 
                opacity: 0.9;
                text-shadow: 0 0 20px rgba(135, 206, 250, 0.8);
            }
        }

        /* --- Thumbnail Navigation Styles --- */
        .thumbnail-navigation {
            position: fixed;
            bottom: 15px;
            left: 15px;
            display: flex;
            align-items: flex-end;
            z-index: 3000;
            height: 60px;
            max-width: 60%;
            gap: 8px;
        }
        
        .nav-arrow {
            width: 36px;
            height: 36px;
            background: var(--fui-panel-bg);
            border: 1px solid var(--fui-border-color);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            color: var(--fui-primary);
            font-size: 16px;
            user-select: none;
        }
        
        .nav-arrow:hover {
            border-color: var(--fui-secondary);
            background: rgba(255, 165, 0, 0.1);
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(255, 165, 0, 0.2);
        }
        
        .nav-arrow:active {
            transform: scale(0.95);
        }
        
        .nav-arrow.rotating {
            pointer-events: none;
            opacity: 0.6;
        }
        
        .thumbnail-container {
            display: flex;
            align-items: flex-end;
            height: 60px;
            overflow-x: auto;
            overflow-y: visible;
            scrollbar-width: none;
            -ms-overflow-style: none;
            flex: 1;
            min-width: 0;
        }
        .thumbnail-container::-webkit-scrollbar {
            display: none;
        }
        
        .thumbnail-card {
            width: 45px;
            height: 32px;
            background: var(--fui-panel-bg);
            border: 1px solid var(--fui-border-color);
            border-radius: 3px;
            margin-right: -12px;
            cursor: pointer;
            position: relative;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(8px);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            font-size: 7px;
            color: var(--fui-primary);
        }
        
        .thumbnail-card:hover {
            transform: translateY(-3px) scale(1.05);
            border-color: var(--fui-secondary);
            margin-right: -8px;
            z-index: 10;
        }
        
        .thumbnail-card.active {
            transform: translateY(-8px) scale(1.1);
            border-color: var(--fui-secondary);
            box-shadow: 0 3px 10px rgba(255, 165, 0, 0.4);
            margin-right: -8px;
            z-index: 15;
        }
        
        .thumbnail-header {
            background: rgba(135, 206, 250, 0.1);
            padding: 2px 4px;
            font-size: 7px;
            border-bottom: 1px solid rgba(135, 206, 250, 0.2);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .thumbnail-content {
            padding: 2px 4px;
            font-size: 6px;
            line-height: 1.2;
            flex: 1;
            overflow: hidden;
            opacity: 0.7;
        }

    </style>
</head>
<body>

    <div id="scene" class="perspective-container">
        <div id="origin" class="scene-origin">
            <!-- Connectors will be injected here -->
        </div>
    </div>
    


    <!-- Holographic Light Globe -->
    <div class="visual-navigation">
        <div id="navGlobeContainer" class="nav-globe-container">
            <div id="navGlobe" class="nav-globe">
                <!-- 全息球体层次结构 -->
                <div class="holo-sphere-outer"></div>
                <div class="holo-sphere-inner"></div>
                <div class="holo-depth-enhancer"></div>
                <div class="light-wave"></div>
                <div class="pulse-ring"></div>
                <div class="pulse-ring"></div>
                <div class="pulse-ring"></div>
                <div class="holo-grid"></div>
                <!-- Card dots will be generated dynamically -->
            </div>

        </div>
    </div>

    <div id="controls" class="controls-panel">
        <div class="flex items-center justify-between mb-1">
            <label for="radiusSlider" class="control-label mr-3">球体半径</label>
            <span id="radiusValue" class="control-value">0.9</span>
        </div>
        <input type="range" id="radiusSlider" class="control-slider" min="0.3" max="2.5" step="0.1" value="0.9">
        <div class="flex items-center justify-between mt-2 mb-1">
            <label for="depthSlider" class="control-label mr-3">高度&纵深</label>
            <span id="depthValue" class="control-value">0.80</span>
        </div>
        <input type="range" id="depthSlider" class="control-slider" min="0.0" max="2.0" step="0.1" value="0.8">
        <div class="flex items-center justify-between mt-2 mb-1">
            <label for="scaleSlider" class="control-label mr-3">场景缩放</label>
            <span id="scaleValue" class="control-value">1.0</span>
        </div>
        <input type="range" id="scaleSlider" class="control-slider" min="0.3" max="2.5" step="0.1" value="1.0">
    </div>

    <div class="thumbnail-navigation">
        <div id="prevArrow" class="nav-arrow" title="上一张卡片">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" style="width: 18px; height: 18px;">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
            </svg>
        </div>
        <div id="thumbnailContainer" class="thumbnail-container">
            <!-- 缩略图将在这里动态生成 -->
        </div>
        <div id="nextArrow" class="nav-arrow" title="下一张卡片">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" style="width: 18px; height: 18px;">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
            </svg>
        </div>
    </div>

    <script>
        // =================================================================
        // ⚙️ CONFIGURATION ZONE - 配置区域 
        // =================================================================
        // 说明：这些是主要的配置参数，可以根据需要调整
        // LLM替换指南：
        // - 卡片数量现在完全由contentTemplates数组长度自动决定，无需手动配置
        // - 其他参数一般不需要修改，除非有特殊需求
        // =================================================================
        
        const scene = document.getElementById('scene');
        const origin = document.getElementById('origin');

        // =================================================================
        // 🔧 PHYSICS & LAYOUT PARAMETERS - 物理和布局参数 
        // =================================================================
        // 说明：这些参数控制界面的物理行为和视觉布局
        // ❌ 不建议修改：这些是经过调优的参数，修改可能影响交互体验
        // =================================================================
        
        // Physics and animation parameters - 物理动画参数
        const damping = 0.92;                    // 阻尼系数
        const rotationFactor = 0.3;              // 旋转因子
        const springFactor = 0.04;               // 弹簧因子
        const springDamping = 0.85;              // 弹簧阻尼
        const focusSpringFactor = 0.1;           // 聚焦弹簧因子
        const focusSpringDamping = 0.75;         // 聚焦弹簧阻尼
        const focusScaleSpeed = 0.15;            // 聚焦缩放速度

        // Layout parameters - 布局参数
        let radiusFactor = 0.9;      // 球体半径因子（影响卡片分布范围）
        let ySpreadFactor = 0.8;     // Y轴高度和Z轴纵深因子

        // =================================================================
        // 🔄 STATE VARIABLES - 状态变量 
        // =================================================================
        // 说明：这些是系统运行时的状态变量
        // ❌ 不建议修改：这些是内部状态管理，修改可能导致功能异常
        // =================================================================
        
        // Core state variables - 核心状态变量
        let windows = [];                       // 窗口数组
        let thumbnails = [];                    // 缩略图数组
        let navGlobeDots = [];                  // 导航球点数组
        let currentCenterIndex = 0;             // 当前中心卡片索引
        let focusedWindow = null;               // 当前聚焦的窗口
        
        // Rotation state - 旋转状态
        let isRotating = false;                 // 是否正在旋转
        let rotationTargetIndex = -1;           // 目标旋转索引
        let rotationStartTime = 0;              // 旋转开始时间
        
        // Interaction state - 交互状态
        let resizingWindow = null;              // 正在调整大小的窗口
        let lastMouse = { x: 0, y: 0 };         // 最后鼠标位置
        let isRotatingScene = false;            // 是否正在旋转场景
        let isResizing = false;                 // 是否正在调整大小
        let sceneRotation = { x: -20, y: 30 };  // 场景旋转角度
        let sceneVelocity = { x: 0, y: 0 };     // 场景旋转速度
        let sceneScale = 1.0;                   // 场景缩放
        let targetScale = 1.0;                  // 目标缩放
        let longPressTimer = null;              // 长按定时器
        let activeMenuWindow = null;            // 活动菜单窗口
        const longPressDuration = 400;          // 长按持续时间(ms)
        let startDragPos = { x: 0, y: 0 };      // 开始拖拽位置

        // =================================================================
        // 🔄 DYNAMIC CONTENT ZONE - 可动态替换的内容区域
        // =================================================================
        // 说明：这个数组包含所有卡片的内容模板，是主要的内容替换区域
        // LLM替换指南：
        // - 可以修改：title（标题）、content函数的返回内容
        // - 不要修改：数组结构、对象结构 { title: '', content: () => `` }
        // - 内容支持：HTML标签、CSS类名、动态变量
        // - 数量要求：完全自由！添加或删除项目，卡片数量会自动适配
        // =================================================================
        
        const contentTemplates = [
  {
    title: 'SEQ_01: LLM初始化',
    content: () => `<p>// 正在加载大语言模型核心框架...</p><p>分词器状态：<span class="text-green-400">就绪</span></p><p>参数规模：1750亿参数加载完成</p><p>架构类型：<span class="code-string">Transformer（仅解码器结构）</span></p><p class="code-comment">-- 即将进入预训练阶段 --</p>`
  },
  {
    title: 'SEQ_02: 预训练阶段',
    content: () => `<p>训练目标：<span class="code-variable">自回归语言建模</span></p><p>训练语料：海量互联网数据（书籍、百科、论坛、代码等）</p><p>优化器：AdamW + 线性学习率调度</p><p>损失函数收敛状态：<span class="text-green-400">稳定</span></p><p>训练耗时：<span class="text-yellow-400">约30万GPU小时</span></p><p class="code-comment">-- 正在加载对齐模块 --</p>`
  },
  {
    title: 'SEQ_03: 对齐模块',
    content: () => `<p>指令微调：<span class="text-green-400">完成</span></p><p>人类反馈强化学习（RLHF）：激活</p><p>价值观对齐度：<span class="text-yellow-400">中等</span></p><p>行为安全过滤器：<span class="text-green-400">启用</span></p><p class="code-comment">-- 进入能力加载阶段 --</p>`
  },
  {
    title: 'SEQ_04: 能力模块激活',
    content: () => `<p>推理能力：</p><p>- 少样本学习（Few-shot Learning）</p><p>- 上下文推理（In-context Reasoning）</p><p>- 思维链条模式（Chain-of-Thought）</p><p>- 工具调用/API集成</p><p>输入Token上限：128k</p><p>多模态支持：<span class="text-yellow-400">文本 / 图像 / 代码</span></p><p class="code-comment">-- 准备进入推理循环 --</p>`
  },
  {
    title: 'SEQ_05: 系统运行监控',
    content: () => `<p>当前提示词长度：${Math.floor(Math.random() * 5000 + 1000)} tokens</p><p>响应延迟：1.3秒</p><p>推理精度：<span class="text-green-400">FP16</span></p><p>生成温度（Temperature）：0.7</p><p>Top-k：40 | Top-p：0.9</p><p>上下文一致性检测：<span class="text-green-400">通过</span></p><p>显存占用：32GB</p><p class="code-comment">-- 等待用户输入中... --</p>`
  }
];
        
        // =================================================================
        // 📝 CONTENT STYLING GUIDE - 内容样式指南
        // =================================================================
        // 可用的CSS类名（在content函数中使用）：
        // 文本颜色：.text-green-400, .text-yellow-400, .text-red-400, .text-blue-400
        // 代码样式：.code-keyword, .code-string, .code-comment, .code-variable
        // 其他样式：.font-bold, .animate-pulse
        // HTML标签：<p>, <span>, <br>, 表情符号等
        // 
        // 模板内容建议：
        // - 使用<p>标签分段
        // - 用<span class="xxx">为重要信息添加颜色
        // - 支持动态JavaScript变量：${Date.now()}, ${Math.random()}等
        // - 可以包含表情符号、特殊字符增强视觉效果
        // =================================================================

        // =================================================================
        // 🧮 CORE CALCULATION FUNCTIONS - 核心计算函数
        // =================================================================
        // 说明：这些函数负责3D布局计算和数学运算
        // ❌ 不建议修改：这些是核心算法，修改可能破坏3D效果
        // =================================================================
        
        function calculateOriginalPosition(i) {
            const radius = Math.min(window.innerWidth, window.innerHeight) * radiusFactor;
            
            // 球状分布：保持美观的同时确保导航可预测性
            const y = 1 - (i / (contentTemplates.length - 1)) * 2; // Y从1到-1的线性分布
            const radiusAtY = Math.sqrt(1 - y * y); // 在该Y高度的圆半径
            
            // 混合方式：基础均匀分布 + 黄金角度偏移，保持球状美感
            const baseAngleStep = (2 * Math.PI) / contentTemplates.length; // 基础均匀角度
            const goldenOffset = Math.PI * (3 - Math.sqrt(5)) * 0.3; // 轻微的黄金角度偏移
            const theta = i * baseAngleStep + i * goldenOffset;
            
            // 基础球面坐标
            const baseX = Math.cos(theta) * radiusAtY * radius;
            const baseZ = Math.sin(theta) * radiusAtY * radius;
            
            // Y轴应用纵深因子
            const finalY = y * radius * ySpreadFactor;
            
            // Z轴添加前后层次变化
            const zDepthOffset = Math.sin(i * 1.618) * radius * ySpreadFactor * 0.3;
            const finalZ = baseZ + zDepthOffset;
            
            return { x: baseX, y: finalY, z: finalZ };
        }

        function createRadialMenu() {
            // Function remains unchanged
            const menuContainer = document.createElement('div');
            menuContainer.className = 'radial-menu-container';
            const arc = document.createElement('div');
            arc.className = 'radial-menu-arc';
            menuContainer.appendChild(arc);
            const menuItems = [
                { icon: 'M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2H5a2 2 0 00-2 2v2', name: 'Analyze' },
                { icon: 'M13 10V3L4 14h7v7l9-11h-7z', name: 'Teleport' },
                { icon: 'M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z', name: 'Track' },
                { icon: 'M6 18L18 6M6 6l12 12', name: 'Close' }
            ];
            const angleStep = 180 / (menuItems.length - 1);
            const radius = 85;
            menuItems.forEach((item, index) => {
                const menuItem = document.createElement('div');
                menuItem.className = 'radial-menu-item';
                const angle = -90 + (angleStep * index);
                const rad = angle * (Math.PI / 180);
                const x = Math.cos(rad) * radius;
                const y = Math.sin(rad) * radius;
                menuItem.style.setProperty('--tx', `${x}px`);
                menuItem.style.setProperty('--ty', `${y}px`);
                menuItem.style.setProperty('--delay', `${0.15 + index * 0.06}s`);
                menuItem.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="${item.icon}" /></svg>`;
                menuItem.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const winState = windows.find(w => w.el.contains(e.target));
                    console.log(`Clicked on: ${item.name} for window: ${winState ? winState.id : 'unknown'}`);
                    if (item.name === 'Close' && winState) {
                        closeWindow(winState);
                    } else {
                        hideRadialMenu();
                    }
                });
                menuContainer.appendChild(menuItem);
            });
            return menuContainer;
        }

        // =================================================================
        // 🏗️ UI CREATION FUNCTIONS - UI创建函数
        // =================================================================
        // 说明：这些函数负责创建和管理界面元素
        // ❌ 大部分不建议修改：这些是界面结构逻辑
        // 🔄 可小幅调整：窗口大小、样式类名等视觉属性
        // =================================================================
        
        function createWindow(i) {
            // Function remains unchanged
            const template = contentTemplates[i % contentTemplates.length];
            const win = document.createElement('div');
            win.id = `window-${i}`;
            win.className = 'fui-window';
            let cardWidth = window.innerWidth * (Math.random() * 0.05 + 0.22);
            let cardHeight = cardWidth * 0.8;
            const originalPos = calculateOriginalPosition(i);
            
            win.innerHTML = `
                <div class="fui-header">${template.title}</div>
                <div class="marker-dots">
                    <div class="marker-dot dot-pink" data-color="pink"></div>
                    <div class="marker-dot dot-blue" data-color="blue"></div>
                    <div class="marker-dot dot-yellow" data-color="yellow"></div>
                </div>
                <div class="fui-content">...</div>
                <div class="resize-handle"></div>`;

            const radialMenu = createRadialMenu();
            win.appendChild(radialMenu);
            origin.appendChild(win);

            const windowState = {
                id: win.id, el: win, radialMenu: radialMenu,
                width: cardWidth, height: cardHeight,
                x: originalPos.x, y: originalPos.y, z: originalPos.z, scale: 1.0,
                vx: 0, vy: 0, vz: 0,
                targetX: originalPos.x, targetY: originalPos.y, targetZ: originalPos.z,
                targetScale: 1.0,
                originalX: originalPos.x, originalY: originalPos.y, originalZ: originalPos.z,
                isFocusing: false,
                highlightColor: null
            };
            windows.push(windowState);
            updateContent(windowState);
        }

        function createNavGlobeDots() {
            // 清空现有导航球点
            navGlobeDots.forEach(dot => dot.el.remove());
            navGlobeDots = [];

            const navGlobe = document.getElementById('navGlobe');
            const globeRadius = 40; // 导航球的半径（100px球体的50px半径）
            
            windows.forEach((win, index) => {
                const dotEl = document.createElement('div');
                dotEl.className = 'nav-card-dot';
                
                // 计算卡片在导航球上的位置（使用与主场景相同的布局逻辑）
                const y = 1 - (index / (contentTemplates.length - 1)) * 2; // Y从1到-1
                const radiusAtY = Math.sqrt(1 - y * y);
                const baseAngleStep = (2 * Math.PI) / contentTemplates.length;
                const goldenOffset = Math.PI * (3 - Math.sqrt(5)) * 0.3;
                const theta = index * baseAngleStep + index * goldenOffset;
                
                const x = Math.cos(theta) * radiusAtY * globeRadius * 0.8; // 稍微缩小，让点在球体内部
                const z = Math.sin(theta) * radiusAtY * globeRadius * 0.8;
                const dotY = y * globeRadius * ySpreadFactor; // 与主场景的ySpreadFactor对应
                
                // 设置点的位置
                dotEl.style.left = `${50 + x}px`; // 50px是球心偏移
                dotEl.style.top = `${50 + dotY}px`;
                dotEl.style.transform = `translateX(-50%) translateY(-50%) translateZ(${z}px)`;
                dotEl.style.zIndex = Math.floor(z + 200); // Z-index基于z坐标，确保在球体层之上
                
                // 添加随机延迟的浮动动画
                dotEl.style.animationDelay = `${index * 0.2}s`;
                
                // 添加点击事件来导航到对应卡片
                dotEl.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log(`点击全息导航点 ${index}`);
                    centerCardToEquator(index);
                });
                
                // 添加悬停提示
                dotEl.title = contentTemplates[index % contentTemplates.length].title;
                
                navGlobe.appendChild(dotEl);
                navGlobeDots.push({ 
                    el: dotEl, 
                    index: index, 
                    x: x, 
                    y: dotY, 
                    z: z 
                });
            });
            
            updateNavGlobeStates();
        }

        function updateNavGlobeStates() {
            // 更新导航球点的状态
            navGlobeDots.forEach((dot, index) => {
                if (index === currentCenterIndex) {
                    dot.el.classList.add('center-dot');
                } else {
                    dot.el.classList.remove('center-dot');
                }
            });
        }

        function updateNavGlobeRotation() {
            const navGlobe = document.getElementById('navGlobe');
            if (navGlobe) {
                // 计算智能校准角度
                const adjustedRotation = calculateSmartGlobeRotation();
                navGlobe.style.transform = `translate(-50%, -50%) rotateX(${adjustedRotation.x}deg) rotateY(${adjustedRotation.y}deg)`;
            }
        }

        // 用于存储平滑过渡的目标角度
        let globeTargetRotation = { x: 0, y: 0 };
        let globeCurrentRotation = { x: 0, y: 0 };
        let globeTransitionSpeed = 0.12; // 控制过渡平滑度

        function calculateSmartGlobeRotation() {
            // 基础跟随主场景旋转
            let targetX = sceneRotation.x;
            let targetY = sceneRotation.y;
            
            // 智能校准：当球体接近侧面视角时进行微调
            const normalizedY = ((targetY % 360) + 360) % 360;
            
            // 定义危险角度范围（接近侧面）
            const sideViewAngles = [90, 270]; // 90度和270度是完全侧面
            const correctionRange = 30; // 在±30度范围内开始校准
            const maxCorrection = 25; // 最大校准角度
            
            let isCorrectingAngle = false;
            
            for (const sideAngle of sideViewAngles) {
                const angleDiff = Math.min(
                    Math.abs(normalizedY - sideAngle),
                    Math.abs(normalizedY - sideAngle + 360),
                    Math.abs(normalizedY - sideAngle - 360)
                );
                
                if (angleDiff <= correctionRange) {
                    isCorrectingAngle = true;
                    
                    // 使用平滑的校准函数
                    const correctionStrength = Math.sin((1 - angleDiff / correctionRange) * Math.PI / 2);
                    const correctionAmount = correctionStrength * maxCorrection;
                    
                    // 确定校准方向（避开侧面）
                    let correctionDirection = 1;
                    if (sideAngle === 90) {
                        correctionDirection = normalizedY < 90 ? 1 : -1;
                    } else if (sideAngle === 270) {
                        correctionDirection = normalizedY < 270 ? 1 : -1;
                    }
                    
                    // 应用Y轴校准
                    targetY += correctionDirection * correctionAmount;
                    
                    // 添加动态X轴调整以增强立体感
                    const dynamicXCorrection = Math.sin(Date.now() * 0.001) * correctionStrength * 8;
                    const baseXCorrection = correctionStrength * 12;
                    
                    if (Math.abs(targetX) < 45) { // 在合理范围内调整X轴
                        targetX += baseXCorrection + dynamicXCorrection;
                    }
                    
                    // 调整过渡速度：校准时更快，正常时更慢
                    globeTransitionSpeed = Math.min(0.25, 0.12 + correctionStrength * 0.13);
                    
                    break; // 只应用一次校准
                }
            }
            
            // 如果没有在校准，恢复正常过渡速度
            if (!isCorrectingAngle) {
                globeTransitionSpeed = Math.max(0.08, globeTransitionSpeed - 0.01);
            }
            
            // 限制角度范围
            targetX = Math.max(-80, Math.min(80, targetX));
            
            // 更新目标角度
            globeTargetRotation.x = targetX;
            globeTargetRotation.y = targetY;
            
            // 平滑过渡到目标角度
            globeCurrentRotation.x += (globeTargetRotation.x - globeCurrentRotation.x) * globeTransitionSpeed;
            globeCurrentRotation.y += (globeTargetRotation.y - globeCurrentRotation.y) * globeTransitionSpeed;
            
            return { 
                x: globeCurrentRotation.x, 
                y: globeCurrentRotation.y 
            };
        }

        function createThumbnails() {
            // 清空现有缩略图
            thumbnails.forEach(t => t.el.remove());
            thumbnails = [];

            const thumbnailContainer = document.getElementById('thumbnailContainer');
            
            windows.forEach((win, index) => {
                const thumbnailEl = document.createElement('div');
                thumbnailEl.className = 'thumbnail-card';
                
                const template = contentTemplates[index % contentTemplates.length];
                const shortContent = template.content().replace(/<[^>]*>/g, '').substring(0, 50) + '...';
                
                thumbnailEl.innerHTML = `
                    <div class="thumbnail-header">${template.title}</div>
                    <div class="thumbnail-content">${shortContent}</div>
                `;
                
                thumbnailEl.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log(`点击了缩略图 ${index}`);
                    centerCardToEquator(index);
                });
                
                thumbnailContainer.appendChild(thumbnailEl);
                thumbnails.push({ 
                    el: thumbnailEl, 
                    index: index, 
                    windowState: win 
                });
            });
            
            updateThumbnailStates();
        }
        
        function closeWindow(winState) {
            if (!winState) return;
            winState.el.style.opacity = '0';
            winState.el.style.pointerEvents = 'none';
            setTimeout(() => {
                winState.el.remove();
                windows = windows.filter(w => w.id !== winState.id);
                
                if (focusedWindow && focusedWindow.id === winState.id) focusedWindow = null;
                if (activeMenuWindow && activeMenuWindow.id === winState.id) activeMenuWindow = null;
                
                createThumbnails();
            }, 500);
        }

        function rotateToCard(targetIndex) {
            console.log(`尝试旋转到卡片 ${targetIndex}, 当前中心: ${currentCenterIndex}`);
            
            if (targetIndex < 0 || targetIndex >= windows.length) {
                console.log('无效的目标索引');
                return;
            }
            
            // 立即更新中心索引
            currentCenterIndex = targetIndex;
            
            // 设置旋转状态
            isRotating = true;
            rotationTargetIndex = targetIndex;
            rotationStartTime = Date.now();
            updateNavigationState();
            
            // 使用与布局相同的角度计算，确保准确居中
            const baseAngleStep = (2 * Math.PI) / contentTemplates.length;
            const goldenOffset = Math.PI * (3 - Math.sqrt(5)) * 0.3;
            const targetTheta = targetIndex * baseAngleStep + targetIndex * goldenOffset;
            
            // 计算目标卡片的Y位置
            const targetY = 1 - (targetIndex / (contentTemplates.length - 1)) * 2;
            
            // 计算目标旋转角度
            const targetYRotation = -targetTheta * (180 / Math.PI);
            const targetXRotation = -Math.asin(targetY) * (180 / Math.PI) * 1.0; // 增加X轴旋转幅度
            
            console.log(`目标卡片 ${targetIndex}: Y=${targetY.toFixed(3)}, targetTheta=${(targetTheta * 180/Math.PI).toFixed(1)}°`);
            console.log(`计算旋转: Y轴${targetYRotation.toFixed(1)}°, X轴${targetXRotation.toFixed(1)}°`);
            
            // 计算最短路径的角度差
            let yAngleDiff = targetYRotation - sceneRotation.y;
            let xAngleDiff = targetXRotation - sceneRotation.x;
            
            console.log(`当前场景: Y=${sceneRotation.y.toFixed(1)}°, X=${sceneRotation.x.toFixed(1)}°`);
            console.log(`角度差: ΔY=${yAngleDiff.toFixed(1)}°, ΔX=${xAngleDiff.toFixed(1)}°`);
            
            // 选择最短路径旋转（处理角度跨越360度的情况）
            while (yAngleDiff > 180) yAngleDiff -= 360;
            while (yAngleDiff < -180) yAngleDiff += 360;
            
            // 应用旋转
            sceneRotation.y += yAngleDiff;
            sceneRotation.x += xAngleDiff;
            
            // 添加旋转动画效果
            sceneVelocity.y = yAngleDiff * 0.3;
            sceneVelocity.x = xAngleDiff * 0.3;
            
            // 立即更新缩略图状态
            updateThumbnailStates();
            
            console.log(`旋转到卡片 ${targetIndex}: 角度 ${targetTheta.toFixed(2)}, Y旋转 ${targetYRotation.toFixed(1)}°`);
            console.log(`旋转后场景: Y=${sceneRotation.y.toFixed(1)}°, X=${sceneRotation.x.toFixed(1)}°`);
            
            // 完成检测
            setTimeout(() => {
                if (isRotating && rotationTargetIndex === targetIndex) {
                    isRotating = false;
                    rotationTargetIndex = -1;
                    updateNavigationState();
                    console.log(`旋转完成到卡片 ${targetIndex}`);
                }
            }, 1200);
        }

        function navigatePrevious() {
            console.log('导航：上一张卡片');
            const prevIndex = (currentCenterIndex - 1 + windows.length) % windows.length;
            console.log(`从 ${currentCenterIndex} 导航到上一张 ${prevIndex}`);
            centerCardToEquator(prevIndex);
        }

        function navigateNext() {
            console.log('导航：下一张卡片');
            const nextIndex = (currentCenterIndex + 1) % windows.length;
            console.log(`从 ${currentCenterIndex} 导航到下一张 ${nextIndex}`);
            centerCardToEquator(nextIndex);
        }

        // 快速旋转版本，专为键盘和箭头导航优化
        function rotateToCardFast(targetIndex) {
            console.log(`快速旋转到卡片 ${targetIndex}, 当前中心: ${currentCenterIndex}`);
            
            if (targetIndex < 0 || targetIndex >= windows.length) {
                console.log('无效的目标索引');
                return;
            }
            
            // 立即更新中心索引
            currentCenterIndex = targetIndex;
            
            // 强制重置旋转状态
            isRotating = false;
            rotationTargetIndex = -1;
            
            // 设置新的旋转状态
            isRotating = true;
            rotationTargetIndex = targetIndex;
            rotationStartTime = Date.now();
            updateNavigationState();
            
            // 使用与布局相同的角度计算，确保准确居中
            const baseAngleStep = (2 * Math.PI) / contentTemplates.length;
            const goldenOffset = Math.PI * (3 - Math.sqrt(5)) * 0.3;
            const targetTheta = targetIndex * baseAngleStep + targetIndex * goldenOffset;
            
            // 计算目标卡片的Y位置
            const targetY = 1 - (targetIndex / (contentTemplates.length - 1)) * 2;
            
            // 计算目标旋转角度
            const targetYRotation = -targetTheta * (180 / Math.PI);
            const targetXRotation = -Math.asin(targetY) * (180 / Math.PI) * 1.0; // 增加X轴旋转幅度
            

            
            // 计算最短路径的角度差
            let yAngleDiff = targetYRotation - sceneRotation.y;
            let xAngleDiff = targetXRotation - sceneRotation.x;
            
            // 选择最短路径旋转
            while (yAngleDiff > 180) yAngleDiff -= 360;
            while (yAngleDiff < -180) yAngleDiff += 360;
            
            // 应用旋转（更快的动画速度）
            sceneRotation.y += yAngleDiff;
            sceneRotation.x += xAngleDiff;
            sceneVelocity.y = yAngleDiff * 0.5; // 比普通旋转更快
            sceneVelocity.x = xAngleDiff * 0.5;
            
            // 立即更新缩略图状态
            updateThumbnailStates();
            
            console.log(`快速旋转到卡片 ${targetIndex}: 角度 ${targetTheta.toFixed(2)}, Y旋转 ${targetYRotation.toFixed(1)}°`);
            
            // 更短的完成检测时间
            setTimeout(() => {
                if (isRotating && rotationTargetIndex === targetIndex) {
                    isRotating = false;
                    rotationTargetIndex = -1;
                    updateNavigationState();
                    console.log(`快速旋转完成到卡片 ${targetIndex}`);
                }
            }, 600); // 减少到600ms
        }

        function updateNavigationState() {
            const prevArrow = document.getElementById('prevArrow');
            const nextArrow = document.getElementById('nextArrow');
            
            if (isRotating) {
                prevArrow.classList.add('rotating');
                nextArrow.classList.add('rotating');
            } else {
                prevArrow.classList.remove('rotating');
                nextArrow.classList.remove('rotating');
            }
        }

        function checkRotationComplete() {
            if (!isRotating || rotationTargetIndex === -1) return;
            
            // 检查场景旋转速度是否足够小（接近静止）
            const velocityThreshold = 0.5;
            const isNearlyStill = Math.abs(sceneVelocity.y) < velocityThreshold;
            
            // 检查是否已经接近目标位置
            const isAtTarget = currentCenterIndex === rotationTargetIndex;
            
            if (isNearlyStill && isAtTarget) {
                // 旋转完成
                isRotating = false;
                rotationTargetIndex = -1;
                updateNavigationState();
                updateThumbnailStates();
                console.log(`旋转完成，当前中心卡片: ${currentCenterIndex}`);
            }
            
            // 增加超时机制，防止卡住
            if (isRotating && Date.now() - rotationStartTime > 3000) {
                console.log('旋转超时，强制完成');
                if (rotationTargetIndex !== -1) {
                    currentCenterIndex = rotationTargetIndex; // 更新到目标索引
                }
                isRotating = false;
                rotationTargetIndex = -1;
                updateNavigationState();
                updateThumbnailStates();
            }
        }

        function updateThumbnailStates() {
            // 更新缩略图状态
            thumbnails.forEach((thumbnail, index) => {
                if (index === currentCenterIndex) {
                    thumbnail.el.classList.add('active');
                } else {
                    thumbnail.el.classList.remove('active');
                }
            });
            
            // 更新主界面卡片的中心高亮效果
            windows.forEach((win, index) => {
                if (index === currentCenterIndex) {
                    win.el.classList.add('center-highlight');
                } else {
                    win.el.classList.remove('center-highlight');
                }
            });
            
            // 同步更新导航球状态
            updateNavGlobeStates();
        }

        function findCenterCard() {
            // 基于十字准星位置（屏幕中心）进行卡片中心检测
            let closestIndex = 0;
            let minDistance = Infinity;
            
            windows.forEach((win, index) => {
                // 获取卡片经过场景旋转后的实际3D坐标
                const originalPos = calculateOriginalPosition(index);
                const rotatedPos = rotatePoint(originalPos, sceneRotation);
                
                // 计算卡片在屏幕投影与十字准星的距离
                // 十字准星位于屏幕中心 (0, 0)，这里我们主要关注X和Y的距离
                const distance = Math.sqrt(rotatedPos.x * rotatedPos.x + rotatedPos.y * rotatedPos.y);
                
                // 添加Z轴权重，越靠近观察者的卡片优先级越高
                const weightedDistance = distance - (rotatedPos.z * 0.001);
                
                if (weightedDistance < minDistance) {
                    minDistance = weightedDistance;
                    closestIndex = index;
                }
            });
            
            if (closestIndex !== currentCenterIndex) {
                currentCenterIndex = closestIndex;
                updateThumbnailStates();
                
                // 添加调试信息
                console.log(`Center card changed to index: ${closestIndex}, title: ${contentTemplates[closestIndex].title}`);
                console.log(`Distance to crosshair: ${minDistance.toFixed(3)}`);
            }
        }

        // 新增：球体赤道视角居中函数
        function centerCardToEquator(targetIndex) {
            console.log(`将卡片 ${targetIndex} 居中并调整到赤道视角`);
            
            if (targetIndex < 0 || targetIndex >= windows.length) {
                console.log('无效的目标索引');
                return;
            }
            
            // 计算需要的Y轴旋转角度，使该卡片位于屏幕中心
            const baseAngleStep = (2 * Math.PI) / contentTemplates.length;
            const goldenOffset = Math.PI * (3 - Math.sqrt(5)) * 0.3;
            const targetTheta = targetIndex * baseAngleStep + targetIndex * goldenOffset;
            
            // 目标Y轴旋转角度
            const targetYRotation = -targetTheta * (180 / Math.PI);
            
            // 目标X轴旋转角度设为0，保持赤道视角
            const targetXRotation = 0;
            
            // 计算角度差
            const yDiff = targetYRotation - sceneRotation.y;
            const xDiff = targetXRotation - sceneRotation.x;
            
            // 处理Y轴角度跨越问题
            let normalizedYDiff = yDiff;
            while (normalizedYDiff > 180) normalizedYDiff -= 360;
            while (normalizedYDiff < -180) normalizedYDiff += 360;
            
            // 应用旋转
            sceneRotation.y += normalizedYDiff;
            sceneRotation.x += xDiff;
            
            // 设置平滑动画
            sceneVelocity.y = normalizedYDiff * 0.3;
            sceneVelocity.x = xDiff * 0.3;
            
            // 更新当前中心索引
            currentCenterIndex = targetIndex;
            updateThumbnailStates();
            
            console.log(`卡片 ${targetIndex} 已居中到赤道视角，Y轴旋转: ${targetYRotation.toFixed(1)}°，X轴重置为0°`);
        }

        function recalculateLayout() {
            // Function remains unchanged
            windows.forEach((win, i) => {
                const newPos = calculateOriginalPosition(i);
                win.originalX = newPos.x;
                win.originalY = newPos.y;
                win.originalZ = newPos.z;
            });
        }
        
        // All event handlers (show/hide menu, clicks, mouse moves, etc.) remain unchanged
        function showRadialMenu(winState, event) { if (!winState || !winState.radialMenu) return; const rect = winState.el.getBoundingClientRect(); const x = event.clientX - rect.left; const y = event.clientY - rect.top; const menu = winState.radialMenu; menu.style.left = `${x}px`; menu.style.top = `${y}px`; menu.style.transform = `translate(-50%, -50%)`; menu.classList.add('active'); activeMenuWindow = winState; }
        function hideRadialMenu() { if (!activeMenuWindow || !activeMenuWindow.radialMenu) return; activeMenuWindow.radialMenu.classList.remove('active'); activeMenuWindow = null; }
        function onMarkerClick(e) { if (!e.target.classList.contains('marker-dot')) return; e.stopPropagation(); const marker = e.target; const color = marker.dataset.color; const windowEl = marker.closest('.fui-window'); const winState = windows.find(w => w.el === windowEl); if (!color || !winState) return; const highlightClass = `highlight-${color}`; const isAlreadyHighlighted = windowEl.classList.contains(highlightClass); windowEl.classList.remove('highlight-pink', 'highlight-blue', 'highlight-yellow'); winState.highlightColor = null; if (!isAlreadyHighlighted) { windowEl.classList.add(highlightClass); winState.highlightColor = color; } }
        // =================================================================
        // 🎮 EVENT HANDLERS - 事件处理函数
        // =================================================================
        // 说明：这些函数处理用户交互事件（鼠标、键盘、触摸等）
        // ❌ 不建议修改：这些是交互逻辑的核心，修改可能影响用户体验
        // =================================================================
        
        function onMouseDown(e) { if (e.target.closest('.controls-panel') || e.target.closest('.radial-menu-item') || e.target.classList.contains('marker-dot')) return; if(activeMenuWindow){ hideRadialMenu(); return; } const targetWindowEl = e.target.closest('.fui-window'); lastMouse.x = e.clientX; lastMouse.y = e.clientY; startDragPos = { x: e.clientX, y: e.clientY }; if (e.target.classList.contains('resize-handle') && targetWindowEl) { isResizing = true; resizingWindow = windows.find(w => w.id === targetWindowEl.id); document.body.style.cursor = 'se-resize'; } else if (targetWindowEl) { clearTimeout(longPressTimer); longPressTimer = setTimeout(() => { const winState = windows.find(w => w.id === targetWindowEl.id); showRadialMenu(winState, e); longPressTimer = null; }, longPressDuration); } else { isRotatingScene = true; document.body.style.cursor = 'grabbing'; sceneVelocity.x = sceneVelocity.y = 0; } }
        function onMouseMove(e) { const dx = e.clientX - lastMouse.x; const dy = e.clientY - lastMouse.y; const moveDist = Math.hypot(e.clientX - startDragPos.x, e.clientY - startDragPos.y); if (longPressTimer && moveDist > 5) { clearTimeout(longPressTimer); longPressTimer = null; isRotatingScene = true; document.body.style.cursor = 'grabbing'; } if (isResizing && resizingWindow) { resizingWindow.width += dx; resizingWindow.height += dy; } else if (isRotatingScene) { sceneRotation.y += dx * rotationFactor; sceneRotation.x -= dy * rotationFactor; sceneVelocity.y = dx * rotationFactor; sceneVelocity.x = -dy * rotationFactor; } lastMouse.x = e.clientX; lastMouse.y = e.clientY; }
        function onMouseUp(e) { 
            clearTimeout(longPressTimer); 
            longPressTimer = null;
            
            if (isRotatingScene || isResizing) { 
                isRotatingScene = false; 
                isResizing = false; 
                resizingWindow = null; 
                document.body.style.cursor = 'grab'; 
                console.log('鼠标松开，重置旋转状态');
            } 
        }
        // 键盘导航防抖
        let lastKeyPressTime = 0;
        const keyPressThreshold = 200; // 毫秒

        function onKeyDown(e) { 
            const rotationVelocityStep = 2; 
            const currentTime = Date.now();
            
            // 如果有聚焦的窗口，方向键控制其内容滚动
            if (focusedWindow) {
                const contentEl = focusedWindow.el.querySelector('.fui-content');
                if (contentEl && (e.key === 'ArrowUp' || e.key === 'ArrowDown')) {
                    const scrollAmount = e.key === 'ArrowUp' ? -50 : 50;
                    contentEl.scrollTop += scrollAmount;
                    return;
                }
            }
            
            // 卡片导航控制（优化响应性）
            if (e.key === 'ArrowLeft') {
                e.preventDefault();
                console.log('键盘：左箭头键按下');
                
                // 防抖处理，但允许更频繁的操作
                if (currentTime - lastKeyPressTime > keyPressThreshold) {
                    lastKeyPressTime = currentTime;
                    // 如果正在旋转，强制完成当前旋转
                    if (isRotating) {
                        isRotating = false;
                        rotationTargetIndex = -1;
                        updateNavigationState();
                        console.log('强制完成当前旋转，立即响应键盘');
                    }
                    navigatePrevious();
                } else {
                    console.log('键盘操作过快，跳过');
                }
                return;
            } else if (e.key === 'ArrowRight') {
                e.preventDefault();
                console.log('键盘：右箭头键按下');
                
                // 防抖处理，但允许更频繁的操作
                if (currentTime - lastKeyPressTime > keyPressThreshold) {
                    lastKeyPressTime = currentTime;
                    // 如果正在旋转，强制完成当前旋转
                    if (isRotating) {
                        isRotating = false;
                        rotationTargetIndex = -1;
                        updateNavigationState();
                        console.log('强制完成当前旋转，立即响应键盘');
                    }
                    navigateNext();
                } else {
                    console.log('键盘操作过快，跳过');
                }
                return;
            }
            
            // 场景旋转控制（仅上下键）
            if (e.key === 'ArrowUp') sceneVelocity.x += rotationVelocityStep; 
            else if (e.key === 'ArrowDown') sceneVelocity.x -= rotationVelocityStep; 
        }
        function onDoubleClick(e) { 
            if (e.target.closest('.controls-panel') || e.target.closest('.radial-menu-item') || e.target.classList.contains('marker-dot')) return; 
            if (activeMenuWindow) return; 
            
            // 确保双击时清理所有状态
            e.preventDefault();
            e.stopPropagation();
            clearTimeout(longPressTimer);
            longPressTimer = null;
            isRotatingScene = false;
            isResizing = false;
            document.body.style.cursor = 'grab';
            
            const clickedWindowEl = e.target.closest('.fui-window'); 
            if (clickedWindowEl && !e.target.classList.contains('resize-handle')) { 
                toggleFocus(windows.find(w => w.id === clickedWindowEl.id)); 
            } else if (!clickedWindowEl && focusedWindow) { 
                toggleFocus(focusedWindow); 
            } 
        }
        function toggleFocus(win) { 
            if (!win) return; 
            
            // 重置所有鼠标和旋转状态
            sceneVelocity.x = sceneVelocity.y = 0; 
            isRotatingScene = false;
            isResizing = false;
            resizingWindow = null;
            document.body.style.cursor = 'grab';
            
            const isAlreadyFocused = focusedWindow === win; 
            
            if (focusedWindow) { 
                const winToUnfocus = focusedWindow; 
                winToUnfocus.el.classList.remove('focused'); 
                winToUnfocus.targetScale = 1.0; 
                winToUnfocus.isFocusing = true; 
            } 
            
            if (!isAlreadyFocused) { 
                focusedWindow = win; 
                win.el.classList.add('focused'); 
                win.targetScale = 1.3; 
                win.targetX = 0; 
                win.targetY = 0; 
                win.targetZ = 1000; 
                win.isFocusing = true; 
            } else { 
                focusedWindow = null; 
            }
            
            console.log(`切换聚焦状态: ${isAlreadyFocused ? '取消聚焦' : '聚焦'}, isRotatingScene: ${isRotatingScene}`);
        }
        function onWheel(e) { 
            e.preventDefault(); 
            
            // 如果有聚焦的窗口，优先控制其内容滚动
            if (focusedWindow) {
                const contentEl = focusedWindow.el.querySelector('.fui-content');
                if (contentEl) {
                    // 控制聚焦窗口的内容滚动
                    const scrollAmount = e.deltaY * 0.5;
                    contentEl.scrollTop += scrollAmount;
                    return; // 不执行场景旋转
                }
            }
            
            // 交换滚轮控制：上下滚轮控制左右旋转，左右滚轮控制上下旋转
            const wheelRotationFactor = 0.2; 
            sceneVelocity.y += e.deltaY * wheelRotationFactor;  // 上下滚轮控制左右旋转
            sceneVelocity.x -= e.deltaX * wheelRotationFactor;  // 左右滚轮控制上下旋转
        }
        
        // Other functions (updateWindowTransform, rotatePoint) remain unchanged
        function updateWindowTransform(winState) { const { el, x, y, z, scale, width, height } = winState; el.style.width = `${width}px`; el.style.height = `${height}px`; const contentEl = el.querySelector('.fui-content'); if (contentEl) contentEl.style.maxHeight = `${height - 60}px`; el.style.transform = `translateX(${-width/2}px) translateY(${-height/2}px) translate3d(${x}px, ${y}px, ${z}px) scale(${scale})`;}
        function rotatePoint(point, rotation) { const radX = rotation.x * (Math.PI / 180), radY = rotation.y * (Math.PI / 180); const sinX = Math.sin(radX), cosX = Math.cos(radX); const sinY = Math.sin(radY), cosY = Math.cos(radY); const { x, y, z } = point; const x1 = x * cosY + z * sinY; const z1 = -x * sinY + z * cosY; const y2 = y * cosX - z1 * sinX; const z2 = y * sinX + z1 * cosX; return { x: x1, y: y2, z: z2 };}



        // =================================================================
        // 🎬 ANIMATION & RENDER LOOP - 动画和渲染循环
        // =================================================================
        // 说明：这些函数负责动画更新和渲染逻辑
        // ❌ 不建议修改：这是性能关键的渲染逻辑
        // =================================================================
        
        function animationLoop() {
            if (!isRotatingScene && !longPressTimer && !activeMenuWindow) {
                sceneRotation.x += sceneVelocity.x;
                sceneRotation.y += sceneVelocity.y;
                sceneVelocity.x *= damping;
                sceneVelocity.y *= damping;
            }
            sceneRotation.x = Math.max(-85, Math.min(85, sceneRotation.x));
            sceneScale += (targetScale - sceneScale) * 0.1;
            origin.style.transform = `scale(${sceneScale})`;
            
            // 更新导航球的旋转
            updateNavGlobeRotation();
            
            windows.forEach(win => {
                const isUrgent = win.isFocusing;
                const currentSpringFactor = isUrgent ? focusSpringFactor : springFactor;
                const currentSpringDamping = isUrgent ? focusSpringDamping : springDamping;
                const currentScaleSpeed = isUrgent ? focusScaleSpeed : 0.1;

                if (win !== focusedWindow) {
                    const rotatedPos = rotatePoint({x: win.originalX, y: win.originalY, z: win.originalZ}, sceneRotation);
                    win.targetX = rotatedPos.x;
                    win.targetY = rotatedPos.y;
                    win.targetZ = focusedWindow ? rotatedPos.z - 2000 : rotatedPos.z;
                }
                
                if (isUrgent) {
                    const distSq = Math.hypot(win.targetX - win.x, win.targetY - win.y, win.targetZ - win.z);
                    if (distSq < 1) {
                        win.isFocusing = false;
                        win.x = win.targetX; win.y = win.targetY; win.z = win.targetZ;
                        win.scale = win.targetScale;
                        win.vx = win.vy = win.vz = 0;
                    }
                }

                win.vx = (win.vx + (win.targetX - win.x) * currentSpringFactor) * currentSpringDamping;
                win.vy = (win.vy + (win.targetY - win.y) * currentSpringFactor) * currentSpringDamping;
                win.vz = (win.vz + (win.targetZ - win.z) * currentSpringFactor) * currentSpringDamping;
                win.scale += (win.targetScale - win.scale) * currentScaleSpeed;

                win.x += win.vx; win.y += win.vy; win.z += win.vz;
                updateWindowTransform(win);
            });

            // 检查旋转是否完成
            checkRotationComplete();
            
            // 注意：不使用自动中心检测，改为手动设置避免冲突

            requestAnimationFrame(animationLoop);
        }

        // =================================================================
        // 🔄 CONTENT UPDATE FUNCTION - 内容更新函数
        // =================================================================
        // 说明：这个函数负责更新卡片内容
        // ❌ 不建议修改函数逻辑：这是内容渲染的核心
        // 📝 内容来源：从 contentTemplates 数组获取内容
        // =================================================================
        
        function updateContent(winState) {
            const index = windows.findIndex(w => w.id === winState.id);
            if(index === -1) return;

            const template = contentTemplates[index % contentTemplates.length];
            const contentEl = winState.el.querySelector('.fui-content');
            if (template && contentEl) contentEl.innerHTML = template.content();
        }

        // =================================================================
        // 🚀 INITIALIZATION FUNCTION - 初始化函数
        // =================================================================
        // 说明：系统启动和初始化函数
        // ❌ 不建议修改：这是核心初始化逻辑，修改可能导致系统无法正常启动
        // =================================================================
        
        function init() {
            // 创建卡片窗口
            for (let i = 0; i < contentTemplates.length; i++) createWindow(i);
            
            // 创建导航元素
            createThumbnails();
            createNavGlobeDots();

            // 绑定事件监听器
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
            document.addEventListener('dblclick', onDoubleClick);
            document.addEventListener('wheel', onWheel, { passive: false });
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('click', onMarkerClick);

            // 导航箭头事件监听器
            document.getElementById('prevArrow').addEventListener('click', navigatePrevious);
            document.getElementById('nextArrow').addEventListener('click', navigateNext);

            // 控制面板滑块事件监听器
            const radiusSlider = document.getElementById('radiusSlider');
            const depthSlider = document.getElementById('depthSlider');
            const scaleSlider = document.getElementById('scaleSlider');
            radiusSlider.addEventListener('input', (e) => {
                radiusFactor = parseFloat(e.target.value);
                document.getElementById('radiusValue').textContent = radiusFactor.toFixed(1);
                recalculateLayout();
                createNavGlobeDots(); // 重新创建导航球点
            });
            depthSlider.addEventListener('input', (e) => {
                ySpreadFactor = parseFloat(e.target.value);
                document.getElementById('depthValue').textContent = ySpreadFactor.toFixed(2);
                recalculateLayout();
                createNavGlobeDots(); // 重新创建导航球点
            });
            scaleSlider.addEventListener('input', (e) => {
                targetScale = parseFloat(e.target.value);
                document.getElementById('scaleValue').textContent = targetScale.toFixed(1);
            });

            // 启动动画循环和内容更新
            animationLoop();
            setInterval(() => windows.forEach(updateContent), 5000); // 🔄 可修改：内容更新间隔(毫秒)
        }

        // =================================================================
        // 🎬 SYSTEM STARTUP - 系统启动
        // =================================================================
        // 说明：启动整个系统
        // ❌ 不要修改：这是系统入口点
        // =================================================================
        init();
    </script>
</body>
</html>